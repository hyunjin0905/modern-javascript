<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title></title>
</head>
<body>
<script>

    const o = {}
    // 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다
    // o.[[Prototype]]
    console.log( o.__proto__ );
    //__proto__ 접근가능

    // 내부 슬롯
    const person = {
        name: "cho"
    }
    console.log(Object.getOwnPropertyDescriptor(person, 'name')) //propertyDescriptor 객체 반환

    // 데이터 프로퍼티
    const person1 = {
        name: "hyunjin"
    }

    // 프로퍼티 동적 생성

    person1.age = 20;
    console.log(Object.getOwnPropertyDescriptors(person1)) // 프로퍼티

    // 접근자 프로퍼티
    const person2 = {
        firstName: "hynnjin",
        lastName: "cho",
        get fullName() {
            return `${this.firstName} ${this.lastName}`;
        },
        set fullName(name) {
            // 배열 구조 할당
            [this.firstName, this.lastName] = name.split(' ');
        }
    };
    console.log(person2);
    //  접근자 프로퍼티를 통한 프로퍼티 값의 저장
    // 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다
    person2.fullName = "hello lee";
    console.log(person2);
    // 접근자 프로퍼티를 통한 프로퍼티 값의 참조
    // 접근하면 getter 함수 호출
    console.log(person2.fullName);

    let descriptor = Object.getOwnPropertyDescriptor(person2, "fullName");
    console.log(descriptor);

    // 접근자 프로퍼티와 데이터프로퍼티를 구별하는 방법
    // 일반객체의 __proto__는  접근자 프로퍼티
    Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');

    // 함수 객체의 prototype 은 데이터 프로퍼티 이다
    Object.getOwnPropertyDescriptor(function () {}, 'prototype')

    // 프로퍼티 정의


</script>

</body>
</html>